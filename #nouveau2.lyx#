#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Projet 2 : Intelligence Artificielle
\end_layout

\begin_layout Title
Le jeu du taquin 
\end_layout

\begin_layout Author
Jessica DA ROSA – Yannick HONORE 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Paragraph*
Le taquin est un jeu solitaire en forme de damier crée dans les années 1870
 aux Etats-Unis.
 À partir de 1891, le jeu devient de plus en plus populaire aux Etats-Unis
 comme en Europe.
 À l'origine, il est composé de 15 petits carreaux numérotés de 1 à 15 dans
 un cadre prévu pour 16 carreaux.
 Le but du jeu est de remettre les carreaux dans l'ordre à partir d'une
 configuration initiale.
 Ce principe est retrouvé dans plusieurs autres jeux comme le Rubik's Cube,
 qui est considéré aujourd'hui comme un descendant du taquin.
\end_layout

\begin_layout Section
II.
 Projet : Jeu du Taquin
\end_layout

\begin_layout Paragraph*
Dans un premier temps, nous allons présenter brièvement en quoi consiste
 le projet, puis les fonctionnalités qu'il présente et enfin les problèmes
 qui ont été rencontrés lors de la réalisation de celui-ci ainsi que les
 solutions qui ont permis de les résoudre.
\end_layout

\begin_layout Subsection
Présentation
\end_layout

\begin_layout Paragraph
Le jeu du taquin consiste à déplacer le trou dans les directions prédéfinies
 (nord, surd, ouest, est) à partir d'un état initial jusqu'à un état final
 en limitant le nombre de déplacements du trou.
 Pour réaliser cela, nous aurons besoin d'un algorithme écrit avec le langage
 de programmation Python, de l'algorithme A*, qui a été étudié en cours,
 et des heuristiques prédéfinies et de la distance de Manhattan servant
 à calculer les distances élémentaires d'un élément d'un état.
\end_layout

\begin_layout Subsection
Fonctionnalités
\end_layout

\begin_layout Standard
L'algorithme se décompose en 2 programmes codés en « Python » :
\end_layout

\begin_layout Itemize
– state.py
\end_layout

\begin_layout Itemize
– search.py 
\end_layout

\begin_layout Itemize
Le programme state.py permet de :
\end_layout

\begin_deeper
\begin_layout Itemize
Dans la classe State de :
\end_layout

\begin_deeper
\begin_layout Itemize
Créer un taquin avec chaque case à leur place : __init__(self, size).
\end_layout

\begin_layout Itemize
Définir si un mouvement est possible : possible(self, move).
\end_layout

\begin_layout Itemize
Effectuer un mouvement avec le trou dans n'importe quelle direction (nord,
 sud, ouest, est) : mU(self), mD(self), mL(self), mR(self), mouve(self,
 toDo)
\end_layout

\begin_layout Itemize
Mélanger le taquin initialisé : shuffle(self, number) et utilisation de
 la bibliothèque random.
\end_layout

\begin_layout Itemize
Obtenir la distance de Haming d'un élément de l'état avec la méthode : distance(
self, character).
\end_layout

\begin_layout Itemize
Savoir si un carreau est à la place qu'il doit occuper à l'état final :
 positions(self).
\end_layout

\begin_layout Itemize
Connaître le nombre de pièces mal placées : nbPieces(self).
\end_layout

\begin_layout Itemize
Pouvoir anticiper quels déplacements je peux effectuer à partir de n'importe
 quel état : possibilities(self).
\end_layout

\begin_layout Itemize
Vérifier si deux taquins sont identiques : __eq__(self, value)
\end_layout

\end_deeper
\begin_layout Itemize
Dans la classe Node de :
\end_layout

\begin_deeper
\begin_layout Itemize
Définir un état père, un état fils, la fonction d'évaluation f = g + h :__init__
(self, stateFather, stateSon, distance, movment).
\end_layout

\begin_layout Itemize
Anticiper les mouvements d'un état fils et calculer la fonction d'évaluation
 qui en résulte : expansePieces(self).
 Ici, on prend en compte que l'heuristique est basé sur le nombre de pièces
 mal placées.
\end_layout

\begin_layout Itemize
Anticiper les mouvements d'un état fils et calculer la fonction d'évaluation
 qui en résulte : expanseH(self, k).
 Pour cette méthode, on prend en compte qu'on expanse en utilisaL'algorithme
 se décompose en 2 programmes codés en « Python » :
\end_layout

\begin_layout Itemize
– state.py
\end_layout

\begin_layout Itemize
– search.py 
\end_layout

\begin_layout Itemize
Le programme state.py permet de :
\end_layout

\begin_deeper
\begin_layout Itemize
Dans la classe State de :
\end_layout

\begin_deeper
\begin_layout Itemize
Créer un taquin avec chaque case à leur place : __init__(self, size).
\end_layout

\begin_layout Itemize
Définir si un mouvement est possible : possible(self, move).
\end_layout

\begin_layout Itemize
Effectuer un mouvement avec le trou dans n'importe quelle direction (nord,
 sud, ouest, est) : mU(self), mD(self), mL(self), mR(self), mouve(self,
 toDo)
\end_layout

\begin_layout Itemize
Mélanger le taquin initialisé : shuffle(self, number) et utilisation de
 la bibliothèque random.
\end_layout

\begin_layout Itemize
Obtenir la distance de Haming d'un élément de l'état avec la méthode : distance(
self, character).
\end_layout

\begin_layout Itemize
Savoir si un carreau est à la place qu'il doit occuper à l'état final :
 positions(self).
\end_layout

\begin_layout Itemize
Connaître le nombre de pièces mal placées : nbPieces(self).
\end_layout

\begin_layout Itemize
Pouvoir anticiper quels déplacements je peux effectuer à partir de n'importe
 quel état : possibilities(self).
\end_layout

\begin_layout Itemize
Vérifier si deux taquins sont identiques : __eq__(self, value)
\end_layout

\end_deeper
\begin_layout Itemize
Dans la classe Node de :
\end_layout

\begin_deeper
\begin_layout Itemize
Définir un état père, un état fils, la fonction d'évaluation f = g + h :__init__
(self, stateFather, stateSon, distance, movment).
\end_layout

\begin_layout Itemize
Anticiper les mouvements d'un état fils et calculer la fonction d'évaluation
 qui en résulte : expansePieces(self).
 Ici, on prend en compte que l'heuristique est basé sur le nombre de pièces
 mal placées.
\end_layout

\begin_layout Itemize
Anticiper les mouvements d'un état fils et calculer la fonction d'évaluation
 qui en résulte : expanseH(self, k).
 Pour cette méthode, on prend en compte qu'on expanse en utilisant la distance
 de manhattan comme heuristique.
\end_layout

\begin_layout Itemize
Réaliser le tableau des heuristiques fourni dans l'énoncé du projet : heuristiqu
e(self, k).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Le programme s1.py permet de :
\end_layout

\begin_deeper
\begin_layout Itemize
Déterminer si un élémént est présent dans une liste comme l'ensemble frontière
 ou bien l'ensemble exploré : exist(list, element).
 
\end_layout

\begin_layout Itemize
Trier l'ensemble frontière lorsque l'on veut y ajouter l'état d'un taquin
 : TrieInsert(list, element).
\end_layout

\begin_layout Itemize
Rechercher quel est le chemin optimal pour résoudre le taquin : search(start,
 h).
 
\end_layout

\end_deeper
\begin_layout Itemize
nt la distance de manhattan comme heuristique.
\end_layout

\begin_layout Itemize
Réaliser le tableau des heuristiques fourni dans l'énoncé du projet : heuristiqu
e(self, k).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Le programme s1.py permet de :
\end_layout

\begin_deeper
\begin_layout Itemize
Déterminer si un élémént est présent dans une liste comme l'ensemble frontière
 ou bien l'ensemble exploré : exist(list, element).
 
\end_layout

\begin_layout Itemize
Trier l'ensemble frontière lorsque l'on veut y ajouter l'état d'un taquin
 : TrieInsert(list, element).
\end_layout

\begin_layout Itemize
Rechercher quel est le chemin optimal pour résoudre le taquin : search(start,
 h).
 
\end_layout

\end_deeper
\begin_layout Section
Problèmes
\end_layout

\begin_layout Subparagraph*
Durant la réalisation du projet, nous avons rencontré plusieurs difficultés
 concernant le mélange aléatoire du taquin, le calcul de et l'affichage
 du chemin et des taquins de ce chemin.
\end_layout

\begin_layout Subparagraph*
Au début, nous avions pour idée de créer des tableaux à double-dimentions
 avec des boucles for pour représenter des taquins.
 Par ailleurs, il était plus simple d'utiliser la bibliothèque numpy pour
 créer et manipuler les taquins.
\end_layout

\begin_layout Subparagraph*
Dans un premier temps, nous avons remarqué que la création d'un taquin directeme
nt mélangé aléatoirement était assez complexe à réaliser car nous arrivions
 sur des résultats présentant des erreurs.
 Nous avons alors décidé de créer le taquin rempli dans l'ordre croissant
 pour ensuite pouvoir le mélanger en faisant des mouvements choisit aléatoiremen
t par l'algorithme.
\end_layout

\begin_layout Subparagraph*
De plus, nous avons mis un temps conséquent à comprendre comment utiliser
 le tableau des heuristiques fourni dans l'énoncé.
 Une fois la notion comprise, nous avons décidé de créer un tableau pour
 y inscrire les coefficients de normalisation afin de pouvoir utiliser un
 modulo 2 pour nous simplifer l'utilisation de ces coefficients lors du
 calcul de la formule de h.
\end_layout

\begin_layout Subparagraph*
Concernant le tableau des heuristiques, il était utilisable pour les taquins
 3x3, contenant 8 numéros.
 Néanmoins, pour les taquins contenant plus de 8 numéros, comme les taquins
 4x4 par exemple, nous avons décidé de définir que Hk serait égal à H6 (distance
 de manhattan) pour obtenir un résultat satisfaisant.
\end_layout

\begin_layout Subparagraph*
L'affichage du chemin optimal fut un problème assez long mais simple à résoudre.
 Le premier mouvement ne s'affichait pas car notre boucle while nous permet
 de remonter de l'état final vers l'état initil en affichant le taquin et
 la direction utilisée en prenant en compte que pour que l'affichage fonctionne
 il fallait que l'état actuel ait un état père.
 Or, l'état initial ne possède pas de père.
 Il nous a donc falluop rajouté un affichage pour cette exception de la
 boucle
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
La matrisse suivante: 
\begin_inset Formula $\begin{bmatrix}2 & 8 & 4\\
1 & 6 & 3\\
7 & 5 & X
\end{bmatrix}$
\end_inset

 est une des representatios du taqui 3x3 generes par notre algorithme et
 c'est cellepour la quelle on a enregistrer quesuqes resultats a fin d'en
 reterir quesuqes conclusions sur l'algorithme concue.
\end_layout

\end_body
\end_document
